package handler

import (
	"net/http"
	"time"

	"github.com/edvin/hosting/internal/api/request"
	"github.com/edvin/hosting/internal/api/response"
	"github.com/edvin/hosting/internal/core"
	"github.com/edvin/hosting/internal/model"
	"github.com/edvin/hosting/internal/platform"
	"github.com/go-chi/chi/v5"
)

type Node struct {
	svc *core.NodeService
}

func NewNode(svc *core.NodeService) *Node {
	return &Node{svc: svc}
}

// ListByCluster godoc
//
//	@Summary		List nodes in a cluster
//	@Description	Returns a paginated list of all nodes in a cluster. Supports search, status filtering, and sorting.
//	@Tags			Nodes
//	@Security		ApiKeyAuth
//	@Param			clusterID	path		string	true	"Cluster ID"
//	@Param			limit		query		int		false	"Page size"		default(50)
//	@Param			cursor		query		string	false	"Pagination cursor"
//	@Param			search		query		string	false	"Search query"
//	@Param			sort		query		string	false	"Sort field"	default(created_at)
//	@Param			status		query		string	false	"Filter by status"
//	@Success		200			{object}	response.PaginatedResponse{items=[]model.Node}
//	@Failure		400			{object}	response.ErrorResponse
//	@Failure		500			{object}	response.ErrorResponse
//	@Router			/clusters/{clusterID}/nodes [get]
func (h *Node) ListByCluster(w http.ResponseWriter, r *http.Request) {
	clusterID, err := request.RequireID(chi.URLParam(r, "clusterID"))
	if err != nil {
		response.WriteError(w, http.StatusBadRequest, err.Error())
		return
	}

	params := request.ParseListParams(r, "created_at")

	nodes, hasMore, err := h.svc.ListByCluster(r.Context(), clusterID, params)
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, err.Error())
		return
	}

	var nextCursor string
	if hasMore && len(nodes) > 0 {
		nextCursor = nodes[len(nodes)-1].ID
	}
	response.WritePaginated(w, http.StatusOK, nodes, nextCursor, hasMore)
}

// Create godoc
//
//	@Summary		Create a node
//	@Description	Synchronously registers a node (VM) in a cluster. Node IDs can be pre-generated by Terraform and are used for Temporal task queue routing. Must specify hostname, IP addresses, shard assignment, and roles. Returns 201 on success.
//	@Tags			Nodes
//	@Security		ApiKeyAuth
//	@Param			clusterID	path		string				true	"Cluster ID"
//	@Param			body		body		request.CreateNode	true	"Node data"
//	@Success		201			{object}	model.Node
//	@Failure		400			{object}	response.ErrorResponse
//	@Failure		500			{object}	response.ErrorResponse
//	@Router			/clusters/{clusterID}/nodes [post]
func (h *Node) Create(w http.ResponseWriter, r *http.Request) {
	clusterID, err := request.RequireID(chi.URLParam(r, "clusterID"))
	if err != nil {
		response.WriteError(w, http.StatusBadRequest, err.Error())
		return
	}

	var req request.CreateNode
	if err := request.Decode(r, &req); err != nil {
		response.WriteError(w, http.StatusBadRequest, err.Error())
		return
	}

	nodeID := req.ID
	if nodeID == "" {
		nodeID = platform.NewID()
	}

	now := time.Now()
	node := &model.Node{
		ID:         nodeID,
		ClusterID:  clusterID,
		ShardID:    req.ShardID,
		Hostname:   req.Hostname,
		IPAddress:  req.IPAddress,
		IP6Address: req.IP6Address,
		Roles:      req.Roles,
		Status:     model.StatusActive,
		CreatedAt:  now,
		UpdatedAt:  now,
	}

	if err := h.svc.Create(r.Context(), node); err != nil {
		response.WriteError(w, http.StatusInternalServerError, err.Error())
		return
	}

	response.WriteJSON(w, http.StatusCreated, node)
}

// Get godoc
//
//	@Summary		Get a node
//	@Description	Returns the details of a single node by ID.
//	@Tags			Nodes
//	@Security		ApiKeyAuth
//	@Param			id	path		string	true	"Node ID"
//	@Success		200	{object}	model.Node
//	@Failure		400	{object}	response.ErrorResponse
//	@Failure		404	{object}	response.ErrorResponse
//	@Router			/nodes/{id} [get]
func (h *Node) Get(w http.ResponseWriter, r *http.Request) {
	id, err := request.RequireID(chi.URLParam(r, "id"))
	if err != nil {
		response.WriteError(w, http.StatusBadRequest, err.Error())
		return
	}

	node, err := h.svc.GetByID(r.Context(), id)
	if err != nil {
		response.WriteError(w, http.StatusNotFound, err.Error())
		return
	}

	response.WriteJSON(w, http.StatusOK, node)
}

// Update godoc
//
//	@Summary		Update a node
//	@Description	Synchronously performs a partial update of a node's hostname, IP addresses, shard assignment, roles, or status. Only provided fields are changed.
//	@Tags			Nodes
//	@Security		ApiKeyAuth
//	@Param			id		path		string				true	"Node ID"
//	@Param			body	body		request.UpdateNode	true	"Node updates"
//	@Success		200		{object}	model.Node
//	@Failure		400		{object}	response.ErrorResponse
//	@Failure		404		{object}	response.ErrorResponse
//	@Failure		500		{object}	response.ErrorResponse
//	@Router			/nodes/{id} [put]
func (h *Node) Update(w http.ResponseWriter, r *http.Request) {
	id, err := request.RequireID(chi.URLParam(r, "id"))
	if err != nil {
		response.WriteError(w, http.StatusBadRequest, err.Error())
		return
	}

	var req request.UpdateNode
	if err := request.Decode(r, &req); err != nil {
		response.WriteError(w, http.StatusBadRequest, err.Error())
		return
	}

	node, err := h.svc.GetByID(r.Context(), id)
	if err != nil {
		response.WriteError(w, http.StatusNotFound, err.Error())
		return
	}

	if req.Hostname != "" {
		node.Hostname = req.Hostname
	}
	if req.IPAddress != nil {
		node.IPAddress = req.IPAddress
	}
	if req.IP6Address != nil {
		node.IP6Address = req.IP6Address
	}
	if req.ShardID != nil {
		node.ShardID = req.ShardID
	}
	if req.Roles != nil {
		node.Roles = req.Roles
	}
	if req.Status != "" {
		node.Status = req.Status
	}

	if err := h.svc.Update(r.Context(), node); err != nil {
		response.WriteError(w, http.StatusInternalServerError, err.Error())
		return
	}

	response.WriteJSON(w, http.StatusOK, node)
}

// Delete godoc
//
//	@Summary		Delete a node
//	@Description	Synchronously removes a node registration from the platform.
//	@Tags			Nodes
//	@Security		ApiKeyAuth
//	@Param			id	path	string	true	"Node ID"
//	@Success		204
//	@Failure		400	{object}	response.ErrorResponse
//	@Failure		500	{object}	response.ErrorResponse
//	@Router			/nodes/{id} [delete]
func (h *Node) Delete(w http.ResponseWriter, r *http.Request) {
	id, err := request.RequireID(chi.URLParam(r, "id"))
	if err != nil {
		response.WriteError(w, http.StatusBadRequest, err.Error())
		return
	}

	if err := h.svc.Delete(r.Context(), id); err != nil {
		response.WriteError(w, http.StatusInternalServerError, err.Error())
		return
	}

	w.WriteHeader(http.StatusNoContent)
}
