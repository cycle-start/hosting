package agent

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/edvin/hosting/internal/agent/runtime"
)

const nginxServerBlockTemplate = `# Auto-generated by node-agent for {{ .TenantName }}/{{ .WebrootName }}
# DO NOT EDIT MANUALLY

{{ if .HasSSL -}}
server {
    listen 80;
    listen [::]:80;
    server_name {{ .ServerNames }};
    return 301 https://$host$request_uri;
}
{{ end -}}

server {
{{ if .HasSSL -}}
    listen 443 ssl;
    listen [::]:443 ssl;

    ssl_certificate     {{ .SSLCertPath }};
    ssl_certificate_key {{ .SSLKeyPath }};
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
{{ else -}}
    listen 80;
    listen [::]:80;
{{ end -}}

    server_name {{ .ServerNames }};
    root {{ .DocumentRoot }};
    index index.html index.htm{{ if eq .Runtime "php" }} index.php{{ end }};

    access_log /var/www/storage/{{ .TenantName }}/logs/{{ .WebrootName }}-access.log;
    error_log  /var/www/storage/{{ .TenantName }}/logs/{{ .WebrootName }}-error.log;

    # Node identification headers for load balancer debugging.
    add_header X-Served-By $hostname always;
    add_header X-Shard "{{ .ShardName }}" always;

    location / {
        try_files $uri $uri/ {{ .TryFilesTarget }};
    }
{{ if eq .Runtime "php" }}
    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/run/php/{{ .TenantName }}-php{{ .RuntimeVersion }}.sock;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\.ht {
        deny all;
    }
{{ end -}}
{{ if eq .Runtime "node" }}
    location / {
        proxy_pass http://127.0.0.1:{{ .ProxyPort }};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
{{ end -}}
{{ if eq .Runtime "python" }}
    location / {
        proxy_pass http://unix:/run/gunicorn/{{ .TenantName }}-{{ .WebrootName }}.sock;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
{{ end -}}
{{ if eq .Runtime "ruby" }}
    location / {
        proxy_pass http://unix:/run/puma/{{ .TenantName }}-{{ .WebrootName }}.sock;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
{{ end -}}
}
`

var nginxTmpl = template.Must(template.New("nginx").Parse(nginxServerBlockTemplate))

// NginxManager generates, writes, and manages nginx configuration files.
type NginxManager struct {
	logger    zerolog.Logger
	configDir string
	certDir   string
	shardName string
}

// NewNginxManager creates a new NginxManager.
func NewNginxManager(logger zerolog.Logger, cfg Config) *NginxManager {
	return &NginxManager{
		logger:    logger.With().Str("component", "nginx-manager").Logger(),
		configDir: cfg.NginxConfigDir,
		certDir:   cfg.CertDir,
	}
}

// SetShardName sets the shard name used in X-Shard response headers.
func (m *NginxManager) SetShardName(name string) {
	m.shardName = name
}

type nginxTemplateData struct {
	TenantName     string
	WebrootName    string
	ShardName      string
	ServerNames    string
	DocumentRoot   string
	Runtime        string
	RuntimeVersion string
	HasSSL         bool
	SSLCertPath    string
	SSLKeyPath     string
	TryFilesTarget string
	ProxyPort      uint32
}

// GenerateConfig produces the nginx server block configuration for a webroot.
func (m *NginxManager) GenerateConfig(webroot *runtime.WebrootInfo, fqdns []*FQDNInfo) (string, error) {
	tenantName := webroot.TenantName
	webrootName := webroot.Name
	rt := webroot.Runtime
	rtVersion := webroot.RuntimeVersion
	publicFolder := webroot.PublicFolder

	// Build server_name list from FQDNs.
	var serverNames []string
	hasSSL := false
	var sslFQDN string

	for _, f := range fqdns {
		serverNames = append(serverNames, f.FQDN)
		if f.SSLEnabled {
			hasSSL = true
			if sslFQDN == "" {
				sslFQDN = f.FQDN
			}
		}
	}

	if len(serverNames) == 0 {
		serverNames = append(serverNames, "_")
	}

	// Build the document root path (under webroots/ on CephFS).
	docRoot := filepath.Join("/var/www/storage", tenantName, "webroots", webrootName)
	if publicFolder != "" {
		docRoot = filepath.Join(docRoot, publicFolder)
	}

	// Determine the try_files fallback target based on the runtime.
	tryFilesTarget := "=404"
	switch rt {
	case "php":
		tryFilesTarget = "/index.php?$query_string"
	case "node", "python", "ruby":
		tryFilesTarget = "@app"
	}

	// Compute a proxy port for Node.js runtimes.
	var proxyPort uint32
	if rt == "node" {
		proxyPort = computeNodePort(tenantName, webrootName)
	}

	// Build SSL paths, but only enable SSL if the certificate files actually
	// exist on disk. Certificates may not be provisioned yet when the webroot
	// is first created — in that case we fall back to plain HTTP and the
	// config will be regenerated once the certificate is installed.
	var sslCertPath, sslKeyPath string
	if hasSSL && sslFQDN != "" {
		sslCertPath = filepath.Join(m.certDir, sslFQDN, "fullchain.pem")
		sslKeyPath = filepath.Join(m.certDir, sslFQDN, "privkey.pem")

		if !fileExists(sslCertPath) || !fileExists(sslKeyPath) {
			m.logger.Warn().
				Str("fqdn", sslFQDN).
				Str("cert_path", sslCertPath).
				Str("key_path", sslKeyPath).
				Msg("SSL certificate files not found on disk, falling back to HTTP-only config")
			hasSSL = false
			sslCertPath = ""
			sslKeyPath = ""
		}
	}

	data := nginxTemplateData{
		TenantName:     tenantName,
		WebrootName:    webrootName,
		ShardName:      m.shardName,
		ServerNames:    strings.Join(serverNames, " "),
		DocumentRoot:   docRoot,
		Runtime:        rt,
		RuntimeVersion: rtVersion,
		HasSSL:         hasSSL,
		SSLCertPath:    sslCertPath,
		SSLKeyPath:     sslKeyPath,
		TryFilesTarget: tryFilesTarget,
		ProxyPort:      proxyPort,
	}

	var buf bytes.Buffer
	if err := nginxTmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("render nginx template: %w", err)
	}

	return buf.String(), nil
}

// WriteConfig writes an nginx configuration file for a tenant/webroot combination.
func (m *NginxManager) WriteConfig(tenantName, webrootName, config string) error {
	sitesDir := filepath.Join(m.configDir, "sites-enabled")
	if err := os.MkdirAll(sitesDir, 0755); err != nil {
		return status.Errorf(codes.Internal, "mkdir sites-enabled: %v", err)
	}

	confPath := filepath.Join(sitesDir, fmt.Sprintf("%s_%s.conf", tenantName, webrootName))

	m.logger.Info().
		Str("tenant", tenantName).
		Str("webroot", webrootName).
		Str("path", confPath).
		Msg("writing nginx config")

	if err := os.WriteFile(confPath, []byte(config), 0644); err != nil {
		return status.Errorf(codes.Internal, "write nginx config %s: %v", confPath, err)
	}

	return nil
}

// RemoveConfig removes the nginx configuration file for a tenant/webroot.
func (m *NginxManager) RemoveConfig(tenantName, webrootName string) error {
	confPath := filepath.Join(m.configDir, "sites-enabled", fmt.Sprintf("%s_%s.conf", tenantName, webrootName))

	m.logger.Info().
		Str("tenant", tenantName).
		Str("webroot", webrootName).
		Str("path", confPath).
		Msg("removing nginx config")

	if err := os.Remove(confPath); err != nil && !os.IsNotExist(err) {
		return status.Errorf(codes.Internal, "remove nginx config %s: %v", confPath, err)
	}

	return nil
}

// Reload tests the nginx configuration and reloads the service.
// If nginx is not running, it starts it instead.
func (m *NginxManager) Reload(ctx context.Context) error {
	m.logger.Info().Msg("testing and reloading nginx")

	// Test configuration first.
	testCmd := exec.CommandContext(ctx, "nginx", "-t")
	m.logger.Debug().Strs("cmd", testCmd.Args).Msg("executing nginx -t")
	if output, err := testCmd.CombinedOutput(); err != nil {
		return status.Errorf(codes.Internal, "nginx config test failed: %s: %v", string(output), err)
	}

	// Check if nginx is running by looking for a valid PID file.
	pidData, err := os.ReadFile("/run/nginx.pid")
	if err != nil || len(bytes.TrimSpace(pidData)) == 0 {
		// Nginx is not running — start it.
		m.logger.Info().Msg("nginx not running, starting it")
		startCmd := exec.CommandContext(ctx, "nginx")
		m.logger.Debug().Strs("cmd", startCmd.Args).Msg("executing nginx")
		if output, err := startCmd.CombinedOutput(); err != nil {
			return status.Errorf(codes.Internal, "nginx start failed: %s: %v", string(output), err)
		}
		return nil
	}

	// Reload nginx.
	reloadCmd := exec.CommandContext(ctx, "nginx", "-s", "reload")
	m.logger.Debug().Strs("cmd", reloadCmd.Args).Msg("executing nginx -s reload")
	if output, err := reloadCmd.CombinedOutput(); err != nil {
		return status.Errorf(codes.Internal, "nginx reload failed: %s: %v", string(output), err)
	}

	return nil
}

// InstallCertificate writes SSL certificate files to the certificate directory.
func (m *NginxManager) InstallCertificate(ctx context.Context, cert *CertificateInfo) error {
	fqdn := cert.FQDN
	certDir := filepath.Join(m.certDir, fqdn)

	m.logger.Info().
		Str("fqdn", fqdn).
		Str("cert_dir", certDir).
		Msg("installing SSL certificate")

	if err := os.MkdirAll(certDir, 0700); err != nil {
		return status.Errorf(codes.Internal, "mkdir cert dir %s: %v", certDir, err)
	}

	// Write the full chain (certificate + chain combined).
	fullchain := cert.CertPEM
	if cert.ChainPEM != "" {
		fullchain = fullchain + "\n" + cert.ChainPEM
	}

	fullchainPath := filepath.Join(certDir, "fullchain.pem")
	if err := os.WriteFile(fullchainPath, []byte(fullchain), 0600); err != nil {
		return status.Errorf(codes.Internal, "write fullchain.pem for %s: %v", fqdn, err)
	}

	// Write the private key.
	privkeyPath := filepath.Join(certDir, "privkey.pem")
	if err := os.WriteFile(privkeyPath, []byte(cert.KeyPEM), 0600); err != nil {
		return status.Errorf(codes.Internal, "write privkey.pem for %s: %v", fqdn, err)
	}

	return nil
}

// CleanOrphanedConfigs removes nginx config files from sites-enabled that are not
// in the expected set. expectedConfigs is a set of config filenames (e.g. "tenantID_webrootName.conf").
// Returns the list of removed filenames. Does NOT reload nginx (caller handles that).
func (m *NginxManager) CleanOrphanedConfigs(expectedConfigs map[string]bool) ([]string, error) {
	sitesDir := filepath.Join(m.configDir, "sites-enabled")

	entries, err := os.ReadDir(sitesDir)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("read sites-enabled dir: %w", err)
	}

	var removed []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		name := entry.Name()

		// Only consider .conf files.
		if !strings.HasSuffix(name, ".conf") {
			continue
		}

		// Skip non-webroot configs (files without underscores, like "default.conf").
		// Webroot configs always have the pattern {tenantID}_{webrootName}.conf.
		baseName := strings.TrimSuffix(name, ".conf")
		if !strings.Contains(baseName, "_") {
			continue
		}

		// Skip expected configs.
		if expectedConfigs[name] {
			continue
		}

		// Remove orphaned config.
		confPath := filepath.Join(sitesDir, name)
		m.logger.Warn().
			Str("path", confPath).
			Str("filename", name).
			Msg("removing orphaned nginx config")

		if err := os.Remove(confPath); err != nil {
			return removed, fmt.Errorf("remove orphaned config %s: %w", confPath, err)
		}
		removed = append(removed, name)
	}

	return removed, nil
}

// fileExists returns true if the given path exists and is a regular file.
func fileExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && !info.IsDir()
}

// computeNodePort derives a deterministic port from the tenant and webroot name.
// Ports are mapped into the range 3000-9999.
func computeNodePort(tenant, webroot string) uint32 {
	// Use a simple hash to compute a port deterministically.
	var h uint32
	for _, c := range tenant + "/" + webroot {
		h = h*31 + uint32(c)
	}
	return 3000 + (h % 7000)
}
