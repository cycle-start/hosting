package runtime

import (
	"bytes"
	"testing"

	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestPHPWorker_ConfigTemplate(t *testing.T) {
	data := workerConfigData{
		TenantName:   "acme",
		WebrootName:  "queue",
		Command:      "/usr/bin/php8.3 artisan queue:work",
		WorkingDir:   "/var/www/storage/acme/webroots/queue",
		NumProcs:     4,
		StopSignal:   "QUIT",
		StopWaitSecs: 60,
		StartSecs:    15,
		StartRetries: 5,
		Environment:  `APP_ENV="production",QUEUE="default"`,
	}

	var buf bytes.Buffer
	err := workerConfigTmpl.Execute(&buf, data)
	require.NoError(t, err)

	config := buf.String()

	// Verify header comment.
	assert.Contains(t, config, "; Auto-generated by node-agent for acme/queue")
	assert.Contains(t, config, "; DO NOT EDIT MANUALLY")

	// Verify program section.
	assert.Contains(t, config, "[program:worker-acme-queue]")

	// Verify command and directory.
	assert.Contains(t, config, "command=/usr/bin/php8.3 artisan queue:work")
	assert.Contains(t, config, "directory=/var/www/storage/acme/webroots/queue")
	assert.Contains(t, config, "user=acme")

	// Verify process settings.
	assert.Contains(t, config, "numprocs=4")
	assert.Contains(t, config, "process_name=%(program_name)s_%(process_num)02d")
	assert.Contains(t, config, "autostart=true")
	assert.Contains(t, config, "autorestart=unexpected")
	assert.Contains(t, config, "startsecs=15")
	assert.Contains(t, config, "startretries=5")
	assert.Contains(t, config, "stopsignal=QUIT")
	assert.Contains(t, config, "stopwaitsecs=60")

	// Verify log paths.
	assert.Contains(t, config, "stdout_logfile=/var/www/storage/acme/logs/worker-queue.log")
	assert.Contains(t, config, "stdout_logfile_maxbytes=10MB")
	assert.Contains(t, config, "stdout_logfile_backups=3")
	assert.Contains(t, config, "stderr_logfile=/var/www/storage/acme/logs/worker-queue.error.log")
	assert.Contains(t, config, "stderr_logfile_maxbytes=10MB")
	assert.Contains(t, config, "stderr_logfile_backups=3")

	// Verify environment.
	assert.Contains(t, config, `environment=APP_ENV="production",QUEUE="default"`)
}

func TestPHPWorker_ConfigTemplate_Defaults(t *testing.T) {
	data := workerConfigData{
		TenantName:   "tenant1",
		WebrootName:  "worker",
		Command:      "/usr/bin/php8.5 artisan queue:work",
		WorkingDir:   "/var/www/storage/tenant1/webroots/worker",
		NumProcs:     1,
		StopSignal:   "TERM",
		StopWaitSecs: 30,
		StartSecs:    10,
		StartRetries: 3,
		Environment:  "",
	}

	var buf bytes.Buffer
	err := workerConfigTmpl.Execute(&buf, data)
	require.NoError(t, err)

	config := buf.String()

	// With numprocs=1, process_name should NOT be present.
	assert.NotContains(t, config, "process_name=")

	// With empty environment, environment line should NOT be present.
	assert.NotContains(t, config, "environment=")

	// Verify defaults are rendered.
	assert.Contains(t, config, "numprocs=1")
	assert.Contains(t, config, "stopsignal=TERM")
	assert.Contains(t, config, "stopwaitsecs=30")
	assert.Contains(t, config, "startsecs=10")
	assert.Contains(t, config, "startretries=3")
}

func TestPHPWorker_ConfigTemplate_MultiProc(t *testing.T) {
	data := workerConfigData{
		TenantName:   "tenant1",
		WebrootName:  "jobs",
		Command:      "/usr/bin/php8.5 worker.php",
		WorkingDir:   "/var/www/storage/tenant1/webroots/jobs",
		NumProcs:     3,
		StopSignal:   "TERM",
		StopWaitSecs: 30,
		StartSecs:    10,
		StartRetries: 3,
	}

	var buf bytes.Buffer
	err := workerConfigTmpl.Execute(&buf, data)
	require.NoError(t, err)

	config := buf.String()

	// With numprocs > 1, process_name MUST be present.
	assert.Contains(t, config, "numprocs=3")
	assert.Contains(t, config, "process_name=%(program_name)s_%(process_num)02d")
}

func TestPHPWorker_ConfigTemplate_Environment(t *testing.T) {
	env := map[string]string{
		"DB_HOST":  "localhost",
		"APP_ENV":  "production",
		"QUEUE":    "high",
	}

	formatted := formatEnvironment(env)

	// Keys should be sorted alphabetically.
	assert.Equal(t, `APP_ENV="production",DB_HOST="localhost",QUEUE="high"`, formatted)

	// Render in template to verify it appears correctly.
	data := workerConfigData{
		TenantName:   "tenant1",
		WebrootName:  "worker",
		Command:      "/usr/bin/php8.5 worker.php",
		WorkingDir:   "/var/www/storage/tenant1/webroots/worker",
		NumProcs:     1,
		StopSignal:   "TERM",
		StopWaitSecs: 30,
		StartSecs:    10,
		StartRetries: 3,
		Environment:  formatted,
	}

	var buf bytes.Buffer
	err := workerConfigTmpl.Execute(&buf, data)
	require.NoError(t, err)

	config := buf.String()
	assert.Contains(t, config, `environment=APP_ENV="production",DB_HOST="localhost",QUEUE="high"`)
}

func TestPHPWorker_ConfigPath(t *testing.T) {
	w := NewPHPWorker(zerolog.Nop())

	tests := []struct {
		name     string
		webroot  *WebrootInfo
		expected string
	}{
		{
			name: "standard worker",
			webroot: &WebrootInfo{
				TenantName: "acme",
				Name:       "queue",
			},
			expected: "/etc/supervisor/conf.d/worker-acme-queue.conf",
		},
		{
			name: "different tenant and webroot",
			webroot: &WebrootInfo{
				TenantName: "tenant1",
				Name:       "jobs",
			},
			expected: "/etc/supervisor/conf.d/worker-tenant1-jobs.conf",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			assert.Equal(t, tc.expected, w.configPath(tc.webroot))
		})
	}
}

func TestPHPWorker_ProgramName(t *testing.T) {
	w := NewPHPWorker(zerolog.Nop())

	tests := []struct {
		name     string
		webroot  *WebrootInfo
		expected string
	}{
		{
			name: "standard worker",
			webroot: &WebrootInfo{
				TenantName: "acme",
				Name:       "queue",
			},
			expected: "worker-acme-queue",
		},
		{
			name: "different tenant and webroot",
			webroot: &WebrootInfo{
				TenantName: "tenant1",
				Name:       "jobs",
			},
			expected: "worker-tenant1-jobs",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			assert.Equal(t, tc.expected, w.programName(tc.webroot))
		})
	}
}

func TestResolveCommand(t *testing.T) {
	tests := []struct {
		name     string
		command  string
		version  string
		expected string
	}{
		{
			name:     "php prefix replaced with versioned binary",
			command:  "php artisan queue:work",
			version:  "8.3",
			expected: "/usr/bin/php8.3 artisan queue:work",
		},
		{
			name:     "php prefix with default version",
			command:  "php worker.php",
			version:  "",
			expected: "/usr/bin/php8.5 worker.php",
		},
		{
			name:     "already absolute php path kept as-is",
			command:  "/usr/bin/php8.2 artisan queue:work",
			version:  "8.3",
			expected: "/usr/bin/php8.2 artisan queue:work",
		},
		{
			name:     "script path gets php prepended",
			command:  "artisan queue:work",
			version:  "8.3",
			expected: "/usr/bin/php8.3 artisan queue:work",
		},
		{
			name:     "script path with default version",
			command:  "worker.php",
			version:  "",
			expected: "/usr/bin/php8.5 worker.php",
		},
		{
			name:     "relative script with flags",
			command:  "./bin/worker --queue=high --tries=3",
			version:  "8.4",
			expected: "/usr/bin/php8.4 ./bin/worker --queue=high --tries=3",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			assert.Equal(t, tc.expected, resolveCommand(tc.command, tc.version))
		})
	}
}

func TestPHPWorker_ParseConfig(t *testing.T) {
	// Minimal config â€” only command specified. All other fields should get defaults.
	cfg, err := parseConfig(`{"command": "artisan queue:work"}`)
	require.NoError(t, err)

	assert.Equal(t, "artisan queue:work", cfg.Command)
	assert.Equal(t, 1, cfg.NumProcs)
	assert.Equal(t, "TERM", cfg.StopSignal)
	assert.Equal(t, 30, cfg.StopWaitSecs)
	assert.Equal(t, 10, cfg.StartSecs)
	assert.Equal(t, 3, cfg.StartRetries)
	assert.Empty(t, cfg.Directory)
	assert.Nil(t, cfg.Environment)
}

func TestPHPWorker_ParseConfig_FullConfig(t *testing.T) {
	raw := `{
		"command": "artisan queue:work --queue=high",
		"directory": "/custom/dir",
		"num_procs": 4,
		"stop_signal": "QUIT",
		"stop_wait_secs": 60,
		"start_secs": 15,
		"start_retries": 5,
		"environment": {"APP_ENV": "production", "QUEUE": "high"}
	}`

	cfg, err := parseConfig(raw)
	require.NoError(t, err)

	assert.Equal(t, "artisan queue:work --queue=high", cfg.Command)
	assert.Equal(t, "/custom/dir", cfg.Directory)
	assert.Equal(t, 4, cfg.NumProcs)
	assert.Equal(t, "QUIT", cfg.StopSignal)
	assert.Equal(t, 60, cfg.StopWaitSecs)
	assert.Equal(t, 15, cfg.StartSecs)
	assert.Equal(t, 5, cfg.StartRetries)
	assert.Equal(t, map[string]string{"APP_ENV": "production", "QUEUE": "high"}, cfg.Environment)
}

func TestPHPWorker_ParseConfig_MissingCommand(t *testing.T) {
	_, err := parseConfig(`{"num_procs": 2}`)
	require.Error(t, err)
	assert.Contains(t, err.Error(), "command is required")
}

func TestPHPWorker_ParseConfig_InvalidJSON(t *testing.T) {
	_, err := parseConfig(`{invalid}`)
	require.Error(t, err)
	assert.Contains(t, err.Error(), "parse worker config")
}

func TestPHPWorker_ParseConfig_MaxNumProcs(t *testing.T) {
	cfg, err := parseConfig(`{"command": "worker.php", "num_procs": 20}`)
	require.NoError(t, err)

	assert.Equal(t, 8, cfg.NumProcs, "num_procs should be capped at 8")
}

func TestPHPWorker_ParseConfig_ZeroNumProcs(t *testing.T) {
	cfg, err := parseConfig(`{"command": "worker.php", "num_procs": 0}`)
	require.NoError(t, err)

	assert.Equal(t, 1, cfg.NumProcs, "num_procs should default to 1 when zero")
}

func TestFormatEnvironment_Empty(t *testing.T) {
	assert.Equal(t, "", formatEnvironment(nil))
	assert.Equal(t, "", formatEnvironment(map[string]string{}))
}

func TestFormatEnvironment_Sorted(t *testing.T) {
	env := map[string]string{
		"ZEBRA": "last",
		"ALPHA": "first",
		"MIDDLE": "mid",
	}

	result := formatEnvironment(env)
	assert.Equal(t, `ALPHA="first",MIDDLE="mid",ZEBRA="last"`, result)
}

func TestPHPWorker_ImplementsManagerInterface(t *testing.T) {
	w := NewPHPWorker(zerolog.Nop())
	var _ Manager = w
}
