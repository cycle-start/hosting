package runtime

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/rs/zerolog"
)

// WorkerConfig holds the parsed configuration for a PHP worker process.
type WorkerConfig struct {
	Command      string            `json:"command"`
	Directory    string            `json:"directory"`
	NumProcs     int               `json:"num_procs"`
	StopSignal   string            `json:"stop_signal"`
	StopWaitSecs int               `json:"stop_wait_secs"`
	StartSecs    int               `json:"start_secs"`
	StartRetries int               `json:"start_retries"`
	Environment  map[string]string `json:"environment"`
}

const workerConfigTemplate = `; Auto-generated by node-agent for {{ .TenantName }}/{{ .WebrootName }}
; DO NOT EDIT MANUALLY

[program:worker-{{ .TenantName }}-{{ .WebrootName }}]
command={{ .Command }}
directory={{ .WorkingDir }}
user={{ .TenantName }}
numprocs={{ .NumProcs }}
{{- if gt .NumProcs 1 }}
process_name=%(program_name)s_%(process_num)02d
{{- end }}
autostart=true
autorestart=unexpected
startsecs={{ .StartSecs }}
startretries={{ .StartRetries }}
stopsignal={{ .StopSignal }}
stopwaitsecs={{ .StopWaitSecs }}
stdout_logfile=/var/www/storage/{{ .TenantName }}/logs/worker-{{ .WebrootName }}.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=3
stderr_logfile=/var/www/storage/{{ .TenantName }}/logs/worker-{{ .WebrootName }}.error.log
stderr_logfile_maxbytes=10MB
stderr_logfile_backups=3
{{- if .Environment }}
environment={{ .Environment }}
{{- end }}
`

var workerConfigTmpl = template.Must(template.New("workerconfig").Parse(workerConfigTemplate))

// workerConfigData holds template data for rendering a supervisord program config.
type workerConfigData struct {
	TenantName  string
	WebrootName string
	Command     string
	WorkingDir  string
	NumProcs    int
	StopSignal  string
	StopWaitSecs int
	StartSecs   int
	StartRetries int
	Environment string
}

// PHPWorker manages PHP background worker processes via supervisord.
type PHPWorker struct {
	logger zerolog.Logger
}

// NewPHPWorker creates a new PHP worker runtime manager.
func NewPHPWorker(logger zerolog.Logger) *PHPWorker {
	return &PHPWorker{
		logger: logger.With().Str("runtime", "phpworker").Logger(),
	}
}

func (w *PHPWorker) configPath(webroot *WebrootInfo) string {
	return filepath.Join("/etc/supervisor/conf.d", fmt.Sprintf("worker-%s-%s.conf", webroot.TenantName, webroot.Name))
}

func (w *PHPWorker) programName(webroot *WebrootInfo) string {
	return fmt.Sprintf("worker-%s-%s", webroot.TenantName, webroot.Name)
}

// parseConfig parses the RuntimeConfig JSON and applies defaults.
func parseConfig(rawJSON string) (*WorkerConfig, error) {
	var cfg WorkerConfig
	if err := json.Unmarshal([]byte(rawJSON), &cfg); err != nil {
		return nil, fmt.Errorf("parse worker config: %w", err)
	}

	if cfg.Command == "" {
		return nil, fmt.Errorf("parse worker config: command is required")
	}

	if cfg.NumProcs <= 0 {
		cfg.NumProcs = 1
	}
	if cfg.NumProcs > 8 {
		cfg.NumProcs = 8
	}
	if cfg.StopSignal == "" {
		cfg.StopSignal = "TERM"
	}
	if cfg.StopWaitSecs <= 0 {
		cfg.StopWaitSecs = 30
	}
	if cfg.StartSecs <= 0 {
		cfg.StartSecs = 10
	}
	if cfg.StartRetries <= 0 {
		cfg.StartRetries = 3
	}

	return &cfg, nil
}

// resolveCommand replaces a leading "php " prefix with the versioned PHP binary,
// or prepends the versioned binary if no PHP path is specified.
func resolveCommand(command, version string) string {
	if version == "" {
		version = "8.5"
	}
	phpBin := fmt.Sprintf("/usr/bin/php%s", version)

	if strings.HasPrefix(command, "php ") {
		return phpBin + command[3:]
	}
	if strings.HasPrefix(command, "/usr/bin/php") {
		return command
	}
	return phpBin + " " + command
}

// formatEnvironment formats the environment map as a supervisord environment string.
// Keys are sorted for deterministic output.
func formatEnvironment(env map[string]string) string {
	if len(env) == 0 {
		return ""
	}

	keys := make([]string, 0, len(env))
	for k := range env {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	parts := make([]string, 0, len(keys))
	for _, k := range keys {
		parts = append(parts, fmt.Sprintf("%s=%q", k, env[k]))
	}
	return strings.Join(parts, ",")
}

// Configure generates and writes a supervisord program configuration file for the worker.
func (w *PHPWorker) Configure(ctx context.Context, webroot *WebrootInfo) error {
	cfg, err := parseConfig(webroot.RuntimeConfig)
	if err != nil {
		return err
	}

	command := resolveCommand(cfg.Command, webroot.RuntimeVersion)
	workingDir := cfg.Directory
	if workingDir == "" {
		workingDir = filepath.Join("/var/www/storage", webroot.TenantName, "webroots", webroot.Name)
	}

	data := workerConfigData{
		TenantName:   webroot.TenantName,
		WebrootName:  webroot.Name,
		Command:      command,
		WorkingDir:   workingDir,
		NumProcs:     cfg.NumProcs,
		StopSignal:   cfg.StopSignal,
		StopWaitSecs: cfg.StopWaitSecs,
		StartSecs:    cfg.StartSecs,
		StartRetries: cfg.StartRetries,
		Environment:  formatEnvironment(cfg.Environment),
	}

	var buf bytes.Buffer
	if err := workerConfigTmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("render worker config template: %w", err)
	}

	configPath := w.configPath(webroot)

	w.logger.Info().
		Str("tenant", webroot.TenantName).
		Str("webroot", webroot.Name).
		Str("command", command).
		Str("path", configPath).
		Msg("writing supervisord worker config")

	if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil {
		return fmt.Errorf("create supervisor conf dir: %w", err)
	}

	if err := os.WriteFile(configPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("write supervisor config: %w", err)
	}

	return w.supervisorctl(ctx, "reread")
}

// Start updates supervisord and starts the worker program.
func (w *PHPWorker) Start(ctx context.Context, webroot *WebrootInfo) error {
	program := w.programName(webroot)

	w.logger.Info().
		Str("tenant", webroot.TenantName).
		Str("webroot", webroot.Name).
		Str("program", program).
		Msg("starting worker")

	if err := w.supervisorctl(ctx, "update"); err != nil {
		return err
	}
	return w.supervisorctl(ctx, "start", program+":*")
}

// Stop stops the worker program.
func (w *PHPWorker) Stop(ctx context.Context, webroot *WebrootInfo) error {
	program := w.programName(webroot)

	w.logger.Info().
		Str("tenant", webroot.TenantName).
		Str("webroot", webroot.Name).
		Str("program", program).
		Msg("stopping worker")

	// Ignore errors â€” the program may not be running.
	_ = w.supervisorctl(ctx, "stop", program+":*")
	return nil
}

// Reload triggers a full re-read, update, and restart of the worker program.
func (w *PHPWorker) Reload(ctx context.Context, webroot *WebrootInfo) error {
	program := w.programName(webroot)

	w.logger.Info().
		Str("tenant", webroot.TenantName).
		Str("webroot", webroot.Name).
		Str("program", program).
		Msg("reloading worker")

	if err := w.supervisorctl(ctx, "reread"); err != nil {
		return err
	}
	if err := w.supervisorctl(ctx, "update"); err != nil {
		return err
	}
	return w.supervisorctl(ctx, "restart", program+":*")
}

// Remove stops the worker, removes its config file, and cleans up supervisord.
func (w *PHPWorker) Remove(ctx context.Context, webroot *WebrootInfo) error {
	w.Stop(ctx, webroot)

	configPath := w.configPath(webroot)
	w.logger.Info().
		Str("tenant", webroot.TenantName).
		Str("webroot", webroot.Name).
		Str("path", configPath).
		Msg("removing supervisord worker config")

	if err := os.Remove(configPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("remove supervisor config: %w", err)
	}

	if err := w.supervisorctl(ctx, "reread"); err != nil {
		return err
	}
	return w.supervisorctl(ctx, "update")
}

// supervisorctl executes a supervisorctl command.
func (w *PHPWorker) supervisorctl(ctx context.Context, args ...string) error {
	cmd := exec.CommandContext(ctx, "supervisorctl", args...)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("supervisorctl %v: %s: %w", args, string(output), err)
	}
	return nil
}
